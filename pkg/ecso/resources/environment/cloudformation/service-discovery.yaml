Parameters:

    EnvironmentName:
        Description: An environment name that will be prefixed to resource names
        Type: String

    S3BucketName:
        Description: Name of the S3 bucket containing the Lambda source code
        Type: String

    S3Key:
        Description: Path in the S3 bucket to the lambda source code
        Type: String

    DNSZone:
        Description: Select the DNS zone to use for service discovery
        Type: String

    ClusterArn:
        Description: The ARN of the ECS cluster to monitor
        Type: String

Resources:
    CloudWatchEvents:
        Type: AWS::Events::Rule
        Properties:
            Name: !Sub ${EnvironmentName}-ServiceDiscovery-Events
            State: ENABLED
            EventPattern:
                source:
                    - "aws.ecs"
                detail-type:
                    - "ECS Task State Change"
                detail:
                    clusterArn:
                        - !Sub arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:cluster/${EnvironmentName}
            Targets:
                - Arn: !GetAtt LambdaFunction.Arn
                  Id: !Sub ${EnvironmentName}-ServiceDiscovery-Events-Lambda-Target

    LambdaFunction:
        Type: AWS::Lambda::Function
        Properties:
            FunctionName: !Sub ${EnvironmentName}-Service-Discovery
            Handler: index.handler
            Role: !GetAtt LambdaExecutionRole.Arn
            Runtime: nodejs6.10
            Timeout: 300
            Description: A Lambda function that adds SRV records to route53 for containers that have exposed ports
            Environment:
                Variables:
                    DNS_ZONE: !Ref DNSZone
                    CLUSTER_ARN: !Ref ClusterArn
            Code:
              ZipFile: !Sub |
                const AWS = require('aws-sdk');

                AWS.config.update({
                    region: '${AWS::Region}'
                });

                const ecs = new AWS.ECS();
                const ec2 = new AWS.EC2();
                const r53 = new AWS.Route53();

                /*
                  Creates a route 53 change batch
                  */
                const changeBatch = (action, zoneId, resourceRecordSet) => ({
                    ChangeBatch: {
                        Changes: [{
                            Action: action,
                            ResourceRecordSet: resourceRecordSet
                        }],
                        Comment: "Created by ecso service discovery lambda"
                    },
                    HostedZoneId: zoneId
                });

                /*
                  Returns a promise for the DNS zone ID of the route 53 zone matching 'name'
                  */
                const getDnsZoneId = name =>
                    r53.listHostedZonesByName({
                        DNSName: name
                    }).promise().then(data => data.HostedZones[0].Id);

                /*
                  Creates an array of route 53 resource record sets for a given container. A record
                  set is created for each port and service name indicated by the presence of
                  SERVICE_<PORT>_NAME environment variables in the task definition
                  */
                const containerResourceRecordSets = (zoneName, containerInstance, taskDefinition, container) =>
                    serviceDiscoveryInfo(container, taskDefinition)
                    .map(info => containerResourceRecordSet(info.name, zoneName, findBinding(info.port, container.networkBindings), containerInstance, container.containerArn));

                /*
                  Returns an array of service discovery info object parsed from the env vars of
                  a container. Each info object has the form { name: string, port: number }
                  */
                const serviceDiscoveryInfo = (container, taskDefinition) =>
                    containerEnv(taskDefinition, container.name)
                    .map(envVarToServiceDiscoveryInfo)
                    .filter(info => info != null);

                /*
                  Creates a resource record set for a container and network binding
                  */
                const containerResourceRecordSet = (serviceName, dnsZone, networkBinding, containerInstance, setIdentifier) => ({
                    Name: serviceName + "." + dnsZone,
                    Type: "SRV",
                    TTL: 0,
                    SetIdentifier: setIdentifier,
                    Weight: 1,
                    ResourceRecords: [{
                        Value: srvRecord(1, 1, networkBinding.hostPort, containerInstance.PrivateDnsName)
                    }]
                });

                /*
                  Creates an SRV DNS record
                  */
                const srvRecord = (priority, weight, port, hostname) =>
                    priority + " " + weight + " " + port + " " + hostname;

                /*
                  Transforms an environment variable in the format SERVICE_<PORT>_NAME=<my.service>
                  into an object in the form { name: my.service, port: <PORT> }. If the environment
                  variable cannot be parsed, null is returned
                  */
                const envVarToServiceDiscoveryInfo = envVar => {
                    const parts = envVar.name.split("_");

                    if (parts.length == 3 && parts[0] == "SERVICE" && parts[2] == "NAME") {
                        return {
                            name: envVar.value,
                            port: parts[1]
                        };
                    }

                    return null;
                }

                /*
                  Returns an array of environment variables for a given container in a
                  task definition
                  */
                const containerEnv = (taskDefinition, name) =>
                    taskDefinition.containerDefinitions.reduce((env, c) =>
                        name == c.name ? c.environment : env, []);


                /*
                  Returns true if the the container has any service discovery env vars
                  */
                const hasServiceDiscoveryEnvVar = (container, taskDefinition) =>
                    serviceDiscoveryInfo(container, taskDefinition).length > 0;

                /*
                  Retrives a binding by container port from a list of bindings
                  */
                const findBinding = (containerPort, bindings) =>
                    (bindings || []).reduce((binding, b) =>
                        String(b.containerPort) == String(containerPort) ? b : binding, {});

                /*
                  Returns a promise for the result of calling the changeResourceRecordSets route 53
                  API method
                  */
                const executeChangeBatch = params => {
                    console.log("Executing change batch ", JSON.stringify(params));
                    return r53.changeResourceRecordSets(params).promise();
                }

                /*
                  Returns a promise for the task definition indicated by arn
                  */
                const getTaskDefinition = arn =>
                    ecs.describeTaskDefinition({
                        taskDefinition: arn
                    }).promise().then(data => data.taskDefinition);

                /*
                  Returns a promise for an ec2 instance matched by id
                  */
                const getEC2Instance = id =>
                    ec2.describeInstances({
                        InstanceIds: [id]
                    }).promise().then(data => findInstanceById(id, data.Reservations[0].Instances));

                /*
                  Finds an ec2 instance by id from an array of ec2 instances
                  */
                const findInstanceById = (id, instances) =>
                    instances.reduce((instance, i) => i.InstanceId === id ? i : instance, null);

                /*
                  Returns a promise for an ec2 container instance with the given arn, who is a
                  member of the given ecs cluster
                  */
                const getContainerInstance = (cluster, arn) =>
                    ecs.describeContainerInstances({
                        cluster: cluster,
                        containerInstances: [arn]
                    }).promise().then(data =>
                        data.containerInstances.length ?
                        getEC2Instance(data.containerInstances[0].ec2InstanceId) :
                        null);

                /*
                  Returns a promise for the result of handling a single ecs task change event
                  */
                const handleEvent = (zoneName, clusterArn, event) => {
                    const desiredState = isTaskStartedEvent(event) ? "RUNNING" : "STOPPED";

                    return Promise.all([
                        getContainerInstance(clusterArn, event.detail.containerInstanceArn),
                        getTaskDefinition(event.detail.taskDefinitionArn),
                        getDnsZoneId(zoneName)
                    ]).then(([instance, taskDefinition, zoneId]) =>
                        updateDnsForContainers(
                            desiredState,
                            filterDiscoverableContainers(event.detail.containers, taskDefinition),
                            zoneId,
                            zoneName,
                            instance,
                            taskDefinition));
                }

                /*
                  Returns a promise that will resolve after updating the DNS entries for a list
                  of containers in a single task definition
                  */
                const updateDnsForContainers = (desiredState, containers, zoneId, zoneName, instance, taskDefinition) =>
                    Promise.all(containers.map(updateDnsForContainer(desiredState, zoneId, zoneName, instance, taskDefinition)));

                /*
                  Returns a promise that will resolve after updating the DNS entries for a single
                  container in a task definition
                  */
                const updateDnsForContainer = (desiredState, zoneId, zoneName, containerInstance, taskDefinition) => container =>
                    executeChangeBatches(
                        containerChangeBatches(
                            desiredState,
                            zoneId,
                            zoneName,
                            containerInstance,
                            taskDefinition,
                            container));

                /*
                  Filters non-discoverable containers from an array of containers
                  */
                const filterDiscoverableContainers = (containers, taskDefinition) =>
                    containers.filter(c => isDiscoverable(c, taskDefinition));

                /*
                  Returns true if a conainer is discoverable. A container must contain at least one network binding,
                  at least one service discovery env var and be in a terminal state in order to be considered
                  discoverable
                  */
                const isDiscoverable = (container, taskDefinition) =>
                    container.networkBindings != null &&
                    hasServiceDiscoveryEnvVar(container, taskDefinition) &&
                    (container.lastStatus === "RUNNING" || container.lastStatus === "STOPPED");

                /*
                  Returns true if an event is actionable. Curently only task started and task stopped events are
                  considered actionable
                  */
                const isActionableEvent = event =>
                    isTaskStartedEvent(event) || isTaskStoppedEvent(event);

                /*
                  Returns true if both the desiredStatus and lastStatus of the task are RUNNING
                  */
                const isTaskStartedEvent = event =>
                    isTaskStateChangedEvent(event) &&
                    (event.detail.desiredStatus === event.detail.lastStatus) &&
                    (event.detail.lastStatus === "RUNNING");

                /*
                  Returns true if the desiredStatus of the task is STOPPED
                  */
                const isTaskStoppedEvent = event =>
                    isTaskStateChangedEvent(event) && (event.detail.desiredStatus === "STOPPED");

                /*
                  Returns true if the event is a task changed event
                  */
                const isTaskStateChangedEvent = event =>
                    event["detail-type"] === "ECS Task State Change";

                /*
                  Returns a promise that wil resolve when all route 53 change batches have been
                  executed
                  */
                const executeChangeBatches = changeBatches =>
                    Promise.all(changeBatches.map(executeChangeBatch));

                /*
                  Returns an array of route 53 change batches for a container. The action for each
                  change set will be determined by the desiredState and the last known container state
                  */
                const containerChangeBatches = (desiredState, zoneId, zoneName, containerInstance, taskDefinition, container) =>
                    containerResourceRecordSets(zoneName, containerInstance, taskDefinition, container)
                    .map(rs => changeBatch(containerAction(desiredState, container), zoneId, rs));

                /*
                  Converts a desiredState and last known container state into an appropriate route53 changeset
                  action. If either the desired or know state are STOPPED then return the delete action, otherwise
                  UPSERT
                  */
                const containerAction = (desiredState, container) =>
                    (container.lastStatus === "STOPPED" || desiredState === "STOPPED") ? "DELETE" : "UPSERT";

                /*
                  Lambda entry point
                  */
                exports.handler = function(event, context, cb) {
                    console.log(JSON.stringify(event));

                    if (isActionableEvent(event)) {
                        handleEvent(process.env.DNS_ZONE, process.env.CLUSTER_ARN, event)
                            .then(val => {
                                console.log(JSON.stringify(val));
                                cb(null, val);
                            })
                            .catch(err => {
                                cb(err);
                            });
                    } else {
                        cb(null, "Skipping unhandleable event");
                    }
                };


    InvokeLambdaPermission:
        Type: AWS::Lambda::Permission
        Properties:
            FunctionName:
                Ref: LambdaFunction
            Action: "lambda:InvokeFunction"
            Principal: "events.amazonaws.com"
            SourceArn: !GetAtt CloudWatchEvents.Arn

    LambdaExecutionRole:
        Type: AWS::IAM::Role
        Properties:
            Path: "/"
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    - Effect: Allow
                      Action:
                          - sts:AssumeRole
                      Principal:
                          Service:
                              - lambda.amazonaws.com
            Policies:
                - PolicyName: root
                  PolicyDocument:
                      Version: '2012-10-17'
                      Statement:
                          - Effect: Allow
                            Resource: "*"
                            Action:
                                - logs:CreateLogGroup
                                - logs:CreateLogStream
                                - logs:PutLogEvents
                                - ec2:DescribeInstances
                                - ec2:DescribeInstanceAttribute
                                - ec2:DescribeInstanceStatus
                                - ec2:DescribeHosts
                                - ecs:Describe*
                                - ecs:ListContainerInstances
                                - ecs:SubmitContainerStateChange
                                - ecs:SubmitTaskStateChange
                                - ecs:DescribeContainerInstances
                                - ecs:UpdateContainerInstancesState
                                - ecs:ListTasks
                                - ecs:DescribeTasks
                                - route53:*

Outputs:
    LambdaFunction:
        Value: !Ref LambdaFunction
